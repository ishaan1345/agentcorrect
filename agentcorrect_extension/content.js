// AgentCorrect Browser Extension - Content Script
// Captures corrections to AI agent outputs in real-time

console.log('🚀 AgentCorrect Extension loaded');

// Configuration
const AGENTCORRECT_API = 'http://localhost:8888/capture';

// AI Detection Patterns
const AI_INDICATORS = {
  classes: [
    'ai-generated',
    'suggested-reply',
    'auto-draft',
    'bot-message',
    'ai-response',
    'copilot-suggestion',
    'assistant-message'
  ],
  
  attributes: [
    'data-ai-generated',
    'data-source="ai"',
    'data-bot',
    'data-assistant'
  ],
  
  textPatterns: [
    /Generated by .*(GPT|Claude|AI|Copilot)/i,
    /\[AI\]/,
    /\[Bot\]/,
    /Suggested reply:/i
  ],
  
  // App-specific selectors
  zendesk: {
    composer: '.composer-rich-text-editor',
    aiIndicator: '.suggested-reply',
    draftArea: '[data-test-id="composer-rich-text"]'
  },
  
  intercom: {
    composer: '.composer__input',
    aiIndicator: '.fin-suggestion',
    draftArea: '[data-intercom-target="composer-input"]'
  },
  
  salesforce: {
    composer: '.slds-rich-text-editor',
    aiIndicator: '.einstein-suggestion',
    draftArea: '.emailBodyInput'
  },
  
  servicenow: {
    composer: '.sn-widget-textbox',
    aiIndicator: '.ai-assist',
    draftArea: '[data-name="comments"]'
  }
};

// Detect which app we're in
function detectApp() {
  const hostname = window.location.hostname;
  
  if (hostname.includes('zendesk')) return 'zendesk';
  if (hostname.includes('intercom')) return 'intercom';
  if (hostname.includes('salesforce')) return 'salesforce';
  if (hostname.includes('servicenow')) return 'servicenow';
  if (hostname.includes('hubspot')) return 'hubspot';
  if (hostname.includes('freshdesk')) return 'freshdesk';
  if (hostname.includes('slack')) return 'slack';
  
  return 'unknown';
}

const currentApp = detectApp();
console.log(`📍 Detected app: ${currentApp}`);

// Check if element contains AI-generated content
function isAIGenerated(element) {
  // Check classes
  const classes = element.className || '';
  if (AI_INDICATORS.classes.some(cls => classes.includes(cls))) {
    return true;
  }
  
  // Check attributes
  for (const attr of AI_INDICATORS.attributes) {
    if (element.getAttribute && element.outerHTML.includes(attr)) {
      return true;
    }
  }
  
  // Check text patterns
  const text = element.textContent || element.value || '';
  if (AI_INDICATORS.textPatterns.some(pattern => pattern.test(text))) {
    return true;
  }
  
  // App-specific checks
  if (currentApp in AI_INDICATORS) {
    const appIndicators = AI_INDICATORS[currentApp];
    
    // Check if element is within AI suggestion area
    if (appIndicators.aiIndicator) {
      if (element.closest(appIndicators.aiIndicator)) {
        return true;
      }
    }
  }
  
  // Check parent context
  const parent = element.closest('[data-ai], .ai-content, .bot-content');
  return !!parent;
}

// Extract context information
function extractContext() {
  const context = {
    app: currentApp,
    url: window.location.href,
    timestamp: new Date().toISOString(),
    page_title: document.title
  };
  
  // Extract ticket/case ID
  const ticketPatterns = [
    /ticket[/#]?(\d+)/i,
    /case[/#]?(\d+)/i,
    /issue[/#]?(\d+)/i,
    /conversation[/#]?([a-z0-9-]+)/i,
    /#(\d{4,})/
  ];
  
  for (const pattern of ticketPatterns) {
    const match = window.location.href.match(pattern);
    if (match) {
      context.ticket_id = match[1];
      break;
    }
  }
  
  // Extract user info
  const userElement = document.querySelector(
    '[data-user-name], .current-user, .user-name, [data-test-id="user-menu"]'
  );
  if (userElement) {
    context.user = userElement.textContent.trim();
  }
  
  // App-specific context
  if (currentApp === 'zendesk') {
    const ticketStatus = document.querySelector('.ticket-status');
    if (ticketStatus) context.ticket_status = ticketStatus.textContent;
    
    const assignee = document.querySelector('[data-test-id="ticket-assignee"]');
    if (assignee) context.assignee = assignee.textContent;
  }
  
  if (currentApp === 'intercom') {
    const conversation = document.querySelector('[data-conversation-id]');
    if (conversation) context.conversation_id = conversation.dataset.conversationId;
  }
  
  return context;
}

// Capture and send correction
async function captureCorrection(element, originalContent, correctedContent) {
  // Don't capture if content is the same
  if (originalContent === correctedContent) return;
  
  // Don't capture minor whitespace changes
  if (originalContent.trim() === correctedContent.trim()) return;
  
  const correction = {
    original: originalContent,
    corrected: correctedContent,
    element_type: element.tagName.toLowerCase(),
    element_id: element.id || null,
    element_class: element.className || null,
    context: extractContext(),
    correction_time: Date.now() - (element._agentCorrectFocusTime || Date.now())
  };
  
  console.log('📝 Captured correction:', correction);
  
  // Send to local AgentCorrect server
  try {
    await fetch(AGENTCORRECT_API, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(correction),
      mode: 'no-cors'
    });
    
    // Visual feedback
    showNotification('Correction captured!');
    
    // Store locally for backup
    chrome.storage.local.get(['corrections'], (result) => {
      const corrections = result.corrections || [];
      corrections.push(correction);
      
      // Keep only last 100 corrections locally
      if (corrections.length > 100) {
        corrections.shift();
      }
      
      chrome.storage.local.set({ corrections });
    });
    
  } catch (error) {
    console.error('Failed to send correction:', error);
    
    // Store for later sync
    chrome.storage.local.get(['pending'], (result) => {
      const pending = result.pending || [];
      pending.push(correction);
      chrome.storage.local.set({ pending });
    });
  }
}

// Show notification
function showNotification(message) {
  const notification = document.createElement('div');
  notification.textContent = `✅ ${message}`;
  notification.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #4CAF50;
    color: white;
    padding: 12px 20px;
    border-radius: 4px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 10000;
    font-family: system-ui, -apple-system, sans-serif;
    font-size: 14px;
    animation: slideIn 0.3s ease;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOut 0.3s ease';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

// Add animation styles
const style = document.createElement('style');
style.textContent = `
  @keyframes slideIn {
    from { transform: translateX(100%); }
    to { transform: translateX(0); }
  }
  
  @keyframes slideOut {
    from { transform: translateX(0); }
    to { transform: translateX(100%); }
  }
  
  .agentcorrect-monitoring {
    outline: 2px dashed #2196F3 !important;
    outline-offset: 2px;
  }
`;
document.head.appendChild(style);

// Monitor element for changes
function monitorElement(element) {
  // Skip if already monitoring
  if (element._agentCorrectMonitored) return;
  
  element._agentCorrectMonitored = true;
  
  let originalContent = null;
  let isAIContent = false;
  
  // Focus event - capture original content
  element.addEventListener('focus', () => {
    // Check if this is AI-generated content
    isAIContent = isAIGenerated(element);
    
    if (isAIContent) {
      originalContent = element.value || element.textContent || element.innerHTML;
      element._agentCorrectFocusTime = Date.now();
      
      // Visual indicator
      element.classList.add('agentcorrect-monitoring');
      console.log('👀 Monitoring AI content:', originalContent.substring(0, 50) + '...');
    }
  });
  
  // Blur event - check for changes
  element.addEventListener('blur', () => {
    element.classList.remove('agentcorrect-monitoring');
    
    if (isAIContent && originalContent !== null) {
      const newContent = element.value || element.textContent || element.innerHTML;
      
      if (newContent !== originalContent) {
        captureCorrection(element, originalContent, newContent);
      }
      
      originalContent = null;
      isAIContent = false;
    }
  });
  
  // Also monitor input events for real-time tracking
  let inputTimeout;
  element.addEventListener('input', () => {
    if (isAIContent && originalContent !== null) {
      // Debounce to avoid capturing every keystroke
      clearTimeout(inputTimeout);
      inputTimeout = setTimeout(() => {
        const currentContent = element.value || element.textContent || element.innerHTML;
        
        // Check if user stopped typing for 2 seconds
        if (currentContent !== originalContent) {
          console.log('⏱️ User paused - potential correction point');
        }
      }, 2000);
    }
  });
}

// Find and monitor all input elements
function findAndMonitorInputs() {
  // General selectors
  const selectors = [
    'input[type="text"]',
    'textarea',
    '[contenteditable="true"]',
    '.composer',
    '.editor',
    '.draft',
    '[role="textbox"]'
  ];
  
  // Add app-specific selectors
  if (currentApp in AI_INDICATORS) {
    const appSelectors = AI_INDICATORS[currentApp];
    if (appSelectors.composer) selectors.push(appSelectors.composer);
    if (appSelectors.draftArea) selectors.push(appSelectors.draftArea);
  }
  
  // Find all matching elements
  const elements = document.querySelectorAll(selectors.join(', '));
  elements.forEach(monitorElement);
  
  console.log(`🎯 Monitoring ${elements.length} input elements`);
}

// Observe DOM for new elements
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        // Check if it's an input element
        if (node.matches && (
          node.matches('input, textarea, [contenteditable]') ||
          node.matches('.composer, .editor, .draft')
        )) {
          monitorElement(node);
        }
        
        // Check children
        const inputs = node.querySelectorAll('input, textarea, [contenteditable]');
        inputs.forEach(monitorElement);
      }
    });
  });
});

// Start observing
observer.observe(document.body, {
  childList: true,
  subtree: true
});

// Initial scan
findAndMonitorInputs();

// Re-scan periodically (some apps load content dynamically)
setInterval(findAndMonitorInputs, 5000);

// Listen for messages from popup
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'getStats') {
    chrome.storage.local.get(['corrections'], (result) => {
      const corrections = result.corrections || [];
      sendResponse({
        total: corrections.length,
        app: currentApp,
        recent: corrections.slice(-5)
      });
    });
    return true;
  }
  
  if (request.action === 'forceScan') {
    findAndMonitorInputs();
    sendResponse({ success: true });
    return true;
  }
});

console.log('✨ AgentCorrect Extension ready - watching for AI corrections');